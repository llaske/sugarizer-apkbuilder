<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Composite builds - Gradle User Guide Version 3.3</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide Version 3.3"><link rel="up" href="pt02.html" title="Part&nbsp;II.&nbsp;Working with existing builds"><link rel="prev" href="continuous_build.html" title="Continuous build - Gradle User Guide Version 3.3"><link rel="next" href="tutorial_gradle_gui.html" title="Using the Gradle Graphical User Interface - Gradle User Guide Version 3.3"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="continuous_build.html" title="Continuous build - Gradle User Guide Version 3.3">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 3.3">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="tutorial_gradle_gui.html" title="Using the Gradle Graphical User Interface - Gradle User Guide Version 3.3">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="composite_builds"></a>Chapter&nbsp;10.&nbsp;Composite builds</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="composite_builds.html#composite_build_intro">10.1. What is a composite build?</a></span></dt><dt><span class="section"><a href="composite_builds.html#defining_composite_builds">10.2. Defining a composite build</a></span></dt><dt><span class="section"><a href="composite_builds.html#included_build_declaring_substitutions">10.3. Declaring the dependencies substituted by an included build</a></span></dt><dt><span class="section"><a href="composite_builds.html#included_build_task_dependencies">10.4. Depending on tasks in an included build</a></span></dt><dt><span class="section"><a href="composite_builds.html#current_limitations_and_future_work">10.5. Current limitations and future plans for composite builds</a></span></dt></dl></div><div class="note"><p>
            Composite build is an <a class="link" href="feature_lifecycle.html">incubating</a> feature.
            While useful for many use cases, there are bugs to be discovered, rough edges to smooth,
            and enhancements we plan to make. Thanks for trying it out!
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="composite_build_intro" class="section-anchor" href="#composite_build_intro"></a>10.1.&nbsp;What is a composite build?</h2></div></div></div><p>
            A composite build is simply a build that includes other builds. In many ways a composite build is similar to a Gradle multi-project build, except that instead of including single <code class="literal">projects</code>, complete <code class="literal">builds</code> are included.
        </p>
            Composite builds allow you to:
            <div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>combine builds that are usually developed independently, for instance when trying out a bug fix in a library that your application uses</p></li><li class="listitem"><p>decompose a large multi-project build into smaller, more isolated chunks that can be worked in independently or together as needed</p></li></ul></div><p>
            A build that is included in a composite build is referred to, naturally enough, as an "included build". Included builds do not share any configuration with the composite build, or the other included builds. Each included build is configured and executed in isolation.
        </p><p>
            Included builds interact with other builds via <code class="literal">dependency substitution</code>. If any build in the composite has a dependency that can be satisfied by the included build, then that dependency will be replaced by a project dependency on the included build.
        </p><p>
            By default, Gradle will attempt to determine the dependencies that can be substituted by an included build. However for more flexibility, it is possible to explicitly declare these substitutions if the default ones determined by Gradle are not correct for the composite. See <a class="xref" href="composite_builds.html#included_build_declaring_substitutions">Section&nbsp;10.3, &ldquo;Declaring the dependencies substituted by an included build&rdquo;</a>.
        </p><p>
            As well as consuming outputs via project dependencies, a composite build can directly declare task dependencies on included builds. Included builds are isolated, and are not able to declare task dependencies on the composite build or on other included builds. See <a class="xref" href="composite_builds.html#included_build_task_dependencies">Section&nbsp;10.4, &ldquo;Depending on tasks in an included build&rdquo;</a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="defining_composite_builds" class="section-anchor" href="#defining_composite_builds"></a>10.2.&nbsp;Defining a composite build</h2></div></div></div><p>
            The following examples demonstrate the various ways that 2 Gradle builds that are normally developed separately can be combined into a composite build. For these examples, the <code class="literal">my-utils</code> multi-project build produces 2 different java libraries (<code class="literal">number-utils</code> and <code class="literal">string-utils</code>), and the <code class="literal">my-app</code> build produces an executable using functions from those libraries.
        </p><p>
            The <code class="literal">my-app</code> build does not have direct dependencies on <code class="literal">my-utils</code>. Instead, it declares binary dependencies on the libraries produced by <code class="literal">my-utils</code>.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_basic"></a><p class="title"><b>Example&nbsp;10.1.&nbsp;Dependencies of my-app</b></p><div class="example-contents"><p><code class="filename">my-app/build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'java'</span>
apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'application'</span>
apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'idea'</span>

group <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample"</span>
version <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"1.0"</span>

mainClassName = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample.myapp.Main"</span>

dependencies {
    compile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:number-utils:1.0"</span>
    compile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.sample:string-utils:1.0"</span>
}

repositories {
    jcenter()
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/compositeBuilds/basic</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="command_line_composite" class="section-anchor" href="#command_line_composite"></a>10.2.1.&nbsp;Defining a composite build via <code class="literal">--include-build</code></h3></div></div></div><p>
                The <code class="literal">--include-build</code> command-line argument turns the executed build into a composite, substituting dependencies from the included build into the executed build.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_basic_cli"></a><p class="title"><b>Example&nbsp;10.2.&nbsp;Declaring a command-line composite</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle --include-build ../my-utils run</code></strong></p><pre class="screen">&gt; gradle --include-build ../my-utils run
[composite-build] Configuring build: /home/user/gradle/samples/compositeBuilds/basic/my-utils
:compileJava
:my-utils:number-utils:compileJava
:my-utils:number-utils:processResources UP-TO-DATE
:my-utils:number-utils:classes
:my-utils:number-utils:jar
:my-utils:string-utils:compileJava
:my-utils:string-utils:processResources UP-TO-DATE
:my-utils:string-utils:classes
:my-utils:string-utils:jar
:processResources UP-TO-DATE
:classes
:run
The answer is 42

BUILD SUCCESSFUL
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="settings_defined_composite" class="section-anchor" href="#settings_defined_composite"></a>10.2.2.&nbsp;Defining a composite build via <code class="literal">settings.gradle</code></h3></div></div></div><p>
                It's possible to make the above arrangement persistent, by using <a class="ulink" href="../dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:includeBuild(java.lang.Object)" target="_top"><code class="classname">Settings.includeBuild(java.lang.Object)</code></a> to declare the included build in the <code class="literal">settings.gradle</code> file.
                The <code class="literal">settings.gradle</code> file can be used to add subprojects and included builds at the same time. Included builds are added by location. See the examples below for more details.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="separate_composite" class="section-anchor" href="#separate_composite"></a>10.2.3.&nbsp;Defining a separate composite build</h3></div></div></div><p>
                One downside of the above approach is that it requires you to modify an existing build, rendering it less useful as a standalone build. One way to avoid this is to define a separate composite build, whose only purpose is to combine otherwise separate builds.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_basic_composite"></a><p class="title"><b>Example&nbsp;10.3.&nbsp;Declaring a separate composite</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">rootProject.name=<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'adhoc'</span>

includeBuild <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'../my-app'</span>
includeBuild <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'../my-utils'</span>
</pre></div></div><br class="example-break"><p>
                In this scenario, the 'main' build that is executed is the composite, and it doesn't define any useful tasks to execute itself. In order to execute the 'run' task in the 'my-app' build, the composite build must define a delegating task.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_basic_composite_run"></a><p class="title"><b>Example&nbsp;10.4.&nbsp;Depending on task from included build</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task run {
    dependsOn gradle.includedBuild(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'my-app'</span>).task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':run'</span>)
}
</pre></div></div><br class="example-break"><p>
                More details tasks that depend on included build tasks below.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="included_builds" class="section-anchor" href="#included_builds"></a>10.2.4.&nbsp;Restrictions on included builds</h3></div></div></div><p>
                Most builds can be included into a composite, however there are some limitations.
            </p><p>
                Every included build:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>must have a <code class="literal">settings.gradle</code> file.</p></li><li class="listitem"><p>must not itself be a composite build.</p></li><li class="listitem"><p>must not have a <code class="literal">rootProject.name</code> the same as another included build.</p></li><li class="listitem"><p>must not have a <code class="literal">rootProject.name</code> the same as a top-level project of the composite build.</p></li><li class="listitem"><p>must not have a <code class="literal">rootProject.name</code> the same as the composite build <code class="literal">rootProject.name</code>.</p></li></ul></div><p>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="included_build_declaring_substitutions" class="section-anchor" href="#included_build_declaring_substitutions"></a>10.3.&nbsp;Declaring the dependencies substituted by an included build</h2></div></div></div><p>
            By default, Gradle will configure each included build in order to determine the dependencies it can provide. The algorithm for doing this is very simple: Gradle will inspect the group and name for the projects in the included build, and substitute project dependencies for any external dependency matching <code class="literal">${project.group}:${project.name}</code>.
        </p><p>
            There are cases when the default substitutions determined by Gradle are not sufficient, or they are not correct for a particular composite. For these cases it is possible to explicitly declare the substitutions for an included build. Take for example a single-project build 'unpublished', that produces a java utility library but does not declare a value for the group attribute:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_declared_unpublished"></a><p class="title"><b>Example&nbsp;10.5.&nbsp;Build that does not declare group attribute</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'java'</span>
</pre></div></div><br class="example-break"><p>
            When this build is included in a composite, it will attempt to substitute for the dependency module "undefined:unpublished" ("undefined" being the default value for <code class="literal">project.group</code>, and 'unpublished' being the root project name). Clearly this isn't going to be very useful in a composite build.
            To use the unpublished library unmodified in a composite build, the composing build can explicitly declare the substitutions that it provides:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_declared_unpublished"></a><p class="title"><b>Example&nbsp;10.6.&nbsp;Declaring the substitutions for an included build</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">rootProject.name = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'app'</span>

includeBuild(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'../anonymous-library'</span>) {
    dependencySubstitution {
        substitute module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.sample:number-utils'</span>) with project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':'</span>)
    }
}
</pre></div></div><br class="example-break"><p>
            With this configuration, the "my-app" composite build will substitute any dependency on <code class="literal">org.sample:number-utils</code> with a dependency on the root project of "unpublished".
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="included_build_substitution_requirements" class="section-anchor" href="#included_build_substitution_requirements"></a>10.3.1.&nbsp;Cases where included build substitutions must be declared</h3></div></div></div><p>Many builds that use the <code class="literal">uploadArchives</code> task to publish artifacts will function automatically as an included build, without declared substitutions. Here are some common cases where declared substitutions are required:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When the <code class="literal">archivesBaseName</code> property is used to set the name of the published artifact.</p></li><li class="listitem"><p>When a configuration other than <code class="literal">default</code> is published: this usually means a task other than <code class="literal">uploadArchives</code> is used.</p></li><li class="listitem"><p>When the <code class="literal">MavenPom.addFilter()</code> is used to publish artifacts that don't match the project name.</p></li><li class="listitem"><p>When the <code class="literal">maven-publish</code> or <code class="literal">ivy-publish</code> plugins are used for publishing, and the publication coordinates don't match <code class="literal">${project.group}:${project.name}</code>.</p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="included_build_substitution_limitations" class="section-anchor" href="#included_build_substitution_limitations"></a>10.3.2.&nbsp;Cases where composite build substitutions won't work</h3></div></div></div><p>
                Some builds won't function correctly when included in a composite, even when dependency substitutions are explicitly declared. This limitation is due to the fact that a project dependency that is substituted will always point to the <code class="literal">default</code> configuration of the target project. Any time that the artifacts and dependencies specified for the default configuration of a project don't match what is actually published to a repository, then the composite build may exhibit different behaviour.
            </p><p>
                Here are some cases where the publish module metadata may be different from the project default configuration:
                </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When a configuration other than <code class="literal">default</code> is published.</p></li><li class="listitem"><p>When the <code class="literal">maven-publish</code> or <code class="literal">ivy-publish</code> plugins are used.</p></li><li class="listitem"><p>When the <code class="literal">POM</code> or <code class="literal">ivy.xml</code> file is tweaked as part of publication.</p></li></ul></div><p>
                Builds using these features function incorrectly when included in a composite build. We plan to improve this in the future.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="included_build_task_dependencies" class="section-anchor" href="#included_build_task_dependencies"></a>10.4.&nbsp;Depending on tasks in an included build</h2></div></div></div><p>
            While included builds are isolated from one another and cannot declare direct dependencies, a composite build is able to declare task dependencies on it's included builds. The included builds are accessed using <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuilds" target="_top"><code class="classname">Gradle.getIncludedBuilds()</code></a> or <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuild(java.lang.String)" target="_top"><code class="classname">Gradle.includedBuild(java.lang.String)</code></a>, and a task reference is obtained via the <a class="ulink" href="../dsl/org.gradle.api.initialization.IncludedBuild.html#org.gradle.api.initialization.IncludedBuild:task(java.lang.String)" target="_top"><code class="classname">IncludedBuild.task(java.lang.String)</code></a> method.
        </p><p>
            Using these APIs, it is possible to declare a dependency on a task in a particular included build, or tasks with a certain path in all or some of the included builds.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_tasks_single"></a><p class="title"><b>Example&nbsp;10.7.&nbsp;Depending on a single task from an included build</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task run {
    dependsOn gradle.includedBuild(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'my-app'</span>).task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':run'</span>)
}
</pre></div></div><br class="example-break"><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="compositeBuilds_tasks_multiple"></a><p class="title"><b>Example&nbsp;10.8.&nbsp;Depending on a tasks with path in all included builds</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task publishDeps {
    dependsOn gradle.includedBuilds*.task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':uploadArchives'</span>)
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="current_limitations_and_future_work" class="section-anchor" href="#current_limitations_and_future_work"></a>10.5.&nbsp;Current limitations and future plans for composite builds</h2></div></div></div><p>
            We think composite builds are pretty useful already. However, there are some things that don't yet work the way we'd like, and other improvements that we think will make things work even better.
        </p><p>
            Limitations of the current implementation include:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>No support for included builds that have publications that don't mirror the project default configuration. See <a class="xref" href="composite_builds.html#included_build_substitution_limitations">Section&nbsp;10.3.2, &ldquo;Cases where composite build substitutions won't work&rdquo;</a>.</p></li><li class="listitem"><p>No native support for composite builds in IntelliJ IDEA or Eclipse Buildship. Generating IDEA metadata with <code class="literal">gradle idea</code> is supported.</p></li><li class="listitem"><p>Native builds are not supported. (Binary dependencies are not yet supported for native builds).</p></li><li class="listitem"><p>Substituting plugins only works with the <code class="literal">buildscript</code> block but not with the <code class="literal">plugins</code> block.</p></li></ul></div><p>
        </p><p>
            Improvements we have planned for upcoming releases include:
            </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Better detection of dependency substitution, for build that publish with custom coordinates, builds that produce multiple components, etc. This will reduce the cases where dependency substitution needs to be explicitly declared for an included build.</p></li><li class="listitem"><p>The ability to target a task or tasks in an included build directly from the command line. We are currently exploring syntax options for allowing this functionality, which will remove many cases where a delegating task is required in the composite.</p></li><li class="listitem"><p>Execution of included builds in parallel.</p></li><li class="listitem"><p>Detection of changes to included builds when running with continuous build (<code class="literal">-t</code>).</p></li><li class="listitem"><p>Making the implicit <code class="literal">buildSrc</code> project an included build.</p></li><li class="listitem"><p>Supporting composite-of-composite builds.</p></li></ul></div><p>
        </p></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="continuous_build.html" title="Continuous build - Gradle User Guide Version 3.3">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 3.3">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="tutorial_gradle_gui.html" title="Using the Gradle Graphical User Interface - Gradle User Guide Version 3.3">Next</a></div></div></div></body></html>